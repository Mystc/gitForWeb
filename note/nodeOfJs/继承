1、原型链
    原型链是js实现继承的主要方法。
    利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每
     个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型
     对象的内部指针。
     function SuperType(){
     this.property = true;
     }
     SuperType.prototype.getSuperValue = function(){
     return this.property;
     };
     function SubType(){
     this.subproperty = false;
     }
     //继承了 SuperType
     SubType.prototype = new SuperType();
     SubType.prototype.getSubValue = function (){
     return this.subproperty;
     };
     var instance = new SubType();
     alert(instance.getSuperValue()); //true

        1、默认的原型
         所有引用类型都默认继承Object，这个继承也是通过原型链实现的。所有函数的默认原型都是Object的实例。其中包含一个内部指针，指向Object.prototype。这是所有自定义类型都继承toString()，valueOf()等默认方法的原因。
        2、确定原型与实例的关系
        可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用 instanceof 操作符，只要用
        这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true 。以下几行代码就说明了这
        一点。
        alert(instance instanceof Object); //true
        alert(instance instanceof SuperType); //true
        alert(instance instanceof SubType); //true
        PrototypeChainingExample01.htm
        由于原型链的关系，我们可以说 instance 是 Object 、 SuperType 或 SubType 中任何一个类型
        的实例。因此，测试这三个构造函数的结果都返回了 true 。
        第二种方式是使用 isPrototypeOf() 方法。同样，只要是原型链中出现过的原型，都可以说是该
        原型链所派生的实例的原型，因此 isPrototypeOf() 方法也会返回 true ，如下所示。
        alert(Object.prototype.isPrototypeOf(instance)); //true
        alert(SuperType.prototype.isPrototypeOf(instance)); //true
        alert(SubType.prototype.isPrototypeOf(instance)); //true
        3、谨慎地定义方法
        function SuperType(){
        this.property = true;
        }
        SuperType.prototype.getSuperValue = function(){
        return this.property;
        };
        function SubType(){
        this.subproperty = false;
        }
        //继承了 SuperType
        SubType.prototype = new SuperType();
        // 添加新方法
        SubType.prototype.getSubValue = function (){
        return this.subproperty;
        };
        // 重写超类型中的方法
        SubType.prototype.getSuperValue = function (){
        return false;
        };
        var instance = new SubType();
        alert(instance.getSuperValue()); //false
        在以上代码中，加粗的部分是两个方法的定义。第一个方法 getSubValue() 被添加到了 SubType
        中。第二个方法 getSuperValue() 是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的
        那个方法。换句话说，当通过 SubType 的实例调用 getSuperValue() 时，调用的就是这个重新定义
        的方法；但通过 SuperType 的实例调用 getSuperValue() 时，还会继续调用原来的那个方法。这里
        要格外注意的是，必须在用 SuperType 的实例替换原型之后，再定义这两个方法。
        还有一点需要提醒读者，即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这
        样做就会重写原型链，如下面的例子所示。
        function SuperType(){
        this.property = true;
        }
        SuperType.prototype.getSuperValue = function(){
        return this.property;
        };
        function SubType(){
        this.subproperty = false;
        }
        //继承了 SuperType
        SubType.prototype = new SuperType();
        // 使用字面量添加新方法，会导致上一行代码无效
        SubType.prototype = {
        getSubValue : function (){
        return this.subproperty;
        },
        someOtherMethod : function (){
        return false;
        }
        };
        var instance = new SubType();
        alert(instance.getSuperValue()); //error!
        以上代码展示了刚刚把 SuperType 的实例赋值给原型，紧接着又将原型替换成一个对象字面量而
        导致的问题。由于现在的原型包含的是一个 Object 的实例，而非 SuperType 的实例，因此我们设想
        中的原型链已经被切断—— SubType 和 SuperType 之间已经没有关系了。

    4、原型链的问题：
    function SuperType(){
    this.colors = ["red", "blue", "green"];
    }
    function SubType(){
    }
    //继承了 SuperType
    SubType.prototype = new SuperType();
    var instance1 = new SubType();
    instance1.colors.push("black");
    alert(instance1.colors); //"red,blue,green,black"
    var instance2 = new SubType();
        alert(instance2.colors); //"red,blue,green,black"
    原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，
    应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上
    前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。

  2：借用构造函数（伪造对象或经典继承）
  在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，
  因此通过使用 apply() 和 call() 方法也可以在（将来）新创建的对象上执行构造函数，
  function SuperType(){
  this.colors = ["red", "blue", "green"];
  }
  function SubType(){
  // 继承了 SuperType
  SuperType.call(this);
  }
  var instance1 = new SubType();
  instance1.colors.push("black");
  alert(instance1.colors); //"red,blue,green,black"
  var instance2 = new SubType();
  alert(instance2.colors); //"red,blue,green"

    3、组合继承：
    将原型链和借用构造函数的技术组合到一起。使用原型链实现对原型属性和方法的继承，而通过借用构造函数实现对实例属性的继承。
    function SuperType(name){
    this.name = name;
    this.colors = ["red", "blue", "green"];
    }
    SuperType.prototype.sayName = function(){
    alert(this.name);
    };
    function SubType(name, age){
    //继承属性
    SuperType.call(this, name);
    this.age = age;
    }
    //继承方法
    SubType.prototype = new SuperType();
    SubType.prototype.constructor = SubType;
    SubType.prototype.sayAge = function(){
    alert(this.age);
    };
    var instance1 = new SubType("Nicholas", 29);
    instance1.colors.push("black");
    alert(instance1.colors); //"red,blue,green,black"
    instance1.sayName(); //"Nicholas";
    instance1.sayAge(); //29
    var instance2 = new SubType("Greg", 27);
    alert(instance2.colors); //"red,blue,green"
    instance2.sayName(); //"Greg";
    instance2.sayAge(); //27

    4、原型式继承
    ECMAScript 支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和
    增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。
     工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来
    被构造函数模式所取代。
     构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不
    过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局
    限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。
     原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造
    函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。
    JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函
    数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。
    原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借
    用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的
    属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用
    原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。
    此外，还存在下列可供选择的继承模式。
     原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅
    复制。而复制得到的副本还可以得到进一步改造。
     寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强
    对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问
    题，可以将这个模式与组合继承一起使用。
     寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。