************************************创建对象的方式************************************
1、工厂模式
工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到ECMAScript中无法创建类，开发人员发明了一种函数，用函数来封装特定接口创建对象的细节：
function createPerson(name,age,job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    }
    return o;
}
var person1 = createPerson("Nicholas", 29, "Software Engineer");
var person2 = createPerson("Greg", 27, "Doctor");
工厂模式解决了创建多个相似对象的问题，但是没解决对象识别的问题（即怎样知道一个对象的类型）。

2、构造函数模式
function Person(name, age, job){
this.name = name;
this.age = age;
this.job = job;
this.sayName = function(){
alert(this.name);
};
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
与工厂模式不同之处：
没有显式的创建对象
直接将属性和方法赋给了this对象
没有return语句
构造函数第一个字母大写
实例化经过四步：
创建一个新对象
将构造函数作用域赋给新对象（因此this指向了新对象）
执行构造函数代码（为新对象添加属性）
返回新对象
， person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都
有一个 constructor （构造函数）属性，该属性指向 Person ，如下所示。
alert(person1.constructor == Person); //true
alert(person2.constructor == Person); //true

构造函数和函数唯一区别是他们调用方式不同，任何函数只要通过new操作符来调用就可以作为构造函数

构造函数的缺点：用构造函数每个实例都要重新创建一遍

3、原型模式：
我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。prototype就是通过他调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。即不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下
    function Person(){
    }
    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function(){
    alert(this.name);
    };
    var person1 = new Person();
    person1.sayName(); //"Nicholas"
    var person2 = new Person();
    person2.sayName(); //"Nicholas"
    alert(person1.sayName == person2.sayName); //true

   这些新对象的属性和方法是由实例共享的。即person1和person2访问的都是同一组属性和方法。

   *********************原型对象****************************
    只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，改属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。即Person.prototype.constructor指向Person。通过这个构造函数可以继续为远行对象添加其他属性和方法。


    *********************原型对象****************************
   4、组合使用构造函数和原型模式
   构造函数模式定义实例属性，原型模式定义方法和共享的属性。这样每个实例都有自己的一份实例属性的副本，但是同时共享对方法的引用，最大限度地节省了内存。
function Person(name, age, job){
this.name = name;
this.age = age;
this.job = job;
this.friends = ["Shelby", "Court"];
}
Person.prototype = {
constructor : Person,
sayName : function(){
alert(this.name);
}
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
person1.friends.push("Van");
alert(person1.friends); //"Shelby,Count,Van"
alert(person2.friends); //"Shelby,Count"
alert(person1.friends === person2.friends); //false
alert(person1.sayName === person2.sayName); //true

5、动态原型模式：
function Person(name, age, job){
//属性
this.name = name;
this.age = age;
this.job = job;
// 方法
if (typeof this.sayName != "function"){
Person.prototype.sayName = function(){
alert(this.name);
};
}
}
var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName();

6、寄生构造函数模式
function Person(name, age, job){
var o = new Object();
o.name = name;
o.age = age;
o.job = job;
o.sayName = function(){
alert(this.name);
};
return o;
}
var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName(); //"Nicholas"
这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊
数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。
function SpecialArray(){
//创建数组
var values = new Array();
//添加值
values.push.apply(values, arguments);
//添加方法
values.toPipedString = function(){
return this.join("|");
};
//返回数组
return values;
}
var colors = new SpecialArray("red", "blue", "green");
alert(colors.toPipedString()); //"red|blue|green"
HybridFactoryPatternExample02.htm
在这个例子中，我们创建了一个名叫 SpecialArray 的构造函数。在这个函数内部，首先创建了
一个数组，然后 push() 方法（用构造函数接收到的所有参数）初始化了数组的值。随后，又给数组实
例添加了一个 toPipedString() 方法，该方法返回以竖线分割的数组值。最后，将数组以函数值的形
式返回。接着，我们调用了 SpecialArray 构造函数，向其中传入了用于初始化数组的值，此后又调
用了 toPipedString() 方法。
关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属
性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，
不能依赖 instanceof 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情
况下，不要使用这种模式。

7、稳妥构造函数模式
    所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象，适合一些安全环境（禁止使用this和new），或者在防止数据被其他应用程序改动时使用。
妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的
实例方法不引用 this ；二是不使用 new 操作符调用构造函数。按照稳妥构造函数的要求，可以将前面
的 Person 构造函数重写如下。
function Person(name, age, job){
//创建要返回的对象
var o = new Object();
//可以在这里定义私有变量和函数
//添加方法
o.sayName = function(){
alert(name);
};
//返回对象
return o;
}
注意，在以这种模式创建的对象中，除了使用 sayName() 方法之外，没有其他办法访问 name 的值。
可以像下面使用稳妥的 Person 构造函数。
var friend = Person("Nicholas", 29, "Software Engineer");
friend.sayName(); //"Nicholas"
这样，变量 friend 中保存的是一个稳妥对象，而除了调用 sayName() 方法外，没有别的方式可
以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传
入到构造函数中的原始数据。
************************************创建对象的方式************************************
属性类型：
数据属性：
数据属性包含一个数据值的位置。在这个位置可以读取和写入值，数据属性有4个描述其行为的特性。
Configurable：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值是true。
Enumerable：表示能否通过for-in循环返回属性，默认是true
Writable：表示能否修改属性的值，默认true。
Value：包含这个属性的数据值，读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置，这个特性的默认值是undefined
var person ={
name :"Nicholas"
}；
创建name属性，指定的值是Nicholas，即Value特性将被设置为Nicholas，而对这个值的修改都反映在这个位置。
修改属性默认的特性，必须使用Object.defineProperty()方法，这个方法三个参数：属性所在的对象、属性的名字、和一个描述符对象。其中，描述符对象的属性必须是configurable，enumerable，writable，value，设置其中一个或多个值，可以修改对应的特性值。
如 var person = {};
Object.defineProperty(person,"name",{
writable:"false",//不可修改
configurable:"false",//不可删除
value:"Nicholas"
})
alert(person.name)  //Nicholas
person.name = "ggg";
alert(person.name)  //Nicholas
delete person.name
alert(person.name)  //Nicholas
一旦把属性configurable定义为不可配置，那么就不可以改为可配置了*****





访问器属性：
访问器属性不包含数据值，包含一对getter和setter函数（都是非必需）
读取访问器属性时调用getter，函数返回有效的值，写入访问器属性时，调用setter函数并传入新值，
访问器四个属性：
Configurable：表示能否通过delete属性删除属性从而重新定义属性，默认true
Enumerable：表示能否通过for-in循环返回属性，默认是true
Get：读取属性时调用的函数，默认undefined
Set：写入属性时调用的函数，默认undefined
Object.defineProperty()，访问器属性用其定义
var book = {
_year: 2004,
edition: 1
};
Object.defineProperty(book, "year", {
get: function(){
return this._year;
},
set: function(newValue){
if (newValue > 2004) {
this._year = newValue;
this.edition += newValue - 2004;
}
}
});
book.year = 2005;
alert(book.edition); //2

 Object.getOwnPropertyDescriptor()，取得给地你个属性的描述符
 这个方法有两个参数，1、属性所在的对象 2、要读取其描述符的属性名称