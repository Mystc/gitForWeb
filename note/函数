
函数和方法的区别：
函数（function） 函数是一段代码，需要通过名字来进行调用。它能将一些数据（函数的参数）传递进去进行处理，然后返回一些数据（函数的返回值），也可以不返回数据。

方法（method）是通过对象调用的javascript函数。也就是说，方法也是函数，只是比较特殊的函数。



当将函数和对象和写在一起时，函数（function）就变成了方法（method）
---------------------
作者：怪只怪满眼尽是人间烟火
来源：CSDN
原文：https://blog.csdn.net/weixin_38959210/article/details/79400607
版权声明：本文为博主原创文章，转载请附上博文链接！


参数：
        js函数中参数可以传入任意个，他不根据（）中形参来判断，二十由arguments对象来获取传入的参数，arguments对象是类似数组，但是并不是Array实例，但是可以通过[]如arguments[0] 来获取参数，使用length来判断参数个数
        可以通过对length的判断来实现类似重载效果，且如果有同名函数，后面的函数会覆盖前面的


        alert(sum(10,10))
        //声明函数，js引擎把声明函数放到源代码树的最顶部
        function sum(n1,n2){
        return n1+n2;
        }
        不会报错,代码执行之前，解析器会先进行函数声明

//等价函数表达式（函数表达式）
          alert(sum(10,10))
             var sum = function(n1,n2){
                return n1+n2;
                }
           会报错，因为函数位于一个初始化语句中，不是一个函数声明，在执行到函数所在的语句之前，变量sum中不会保存有对函数的引用。会报错"unexpected identifier"（意外标识符）错误。

           除了访问时机以外，函数声明和函数表达式是等价的


           函数的内部属性：
           arguments：类数组对象，包含着传入参数中的所有参数，有一个callee属性，该属性是一个指针，指向拥有这个arguments的函数
           //阶乘函数
           function factorial(num){
           if(num<=1){
           return 1;
           }else{
           return num*factorial(num-1);
           }
           }
           //消除对于factorial的耦合，保留该函数指针，即使给factorial赋值新的函数，也可以通过获取指针的函数继续调用阶乘函数
      function factorial(num){
           if(num<=1){
           return 1;
           }else{
           return num*arguments.callee(num-1);
           }
           }



           this:this引用的是函数据以执行的环境的对象，在网页的全局作用域中调用函数，this引用的是window。


           caller：保存着调用当前的函数的引用，如果在全局作用域中调用当前函数，返回null
           function outer(){
           inner();
           }
           function inner(){
           arguments.callee.caller();//此时caller指向outer
           }

           函数属性和方法
           函数即对象，每个函数都包含的属性
           length:表示函数希望接收的命名参数的个数
           prototype
           每个函数都包含的两个非继承的方法
           apply():apply()方法接收两个参数:一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象，例如：
           function sum(n1,n2){
           return n1+n2;
           }
           function callSum1(num1,num2){
           return sum.apply(this,arguments);  //传入arguments
           }
            function callSum1(num1,num2){
                      return sum.apply(this,[num1,num2]);//传入数组
                      }
             上例中，传入的this由于是在全局作用域中调用，所以传入的是window对象，


           call()：使用call方法，第一个参数也是this，但是后续参数必须是逐个列举出来，不能通过arguments获取数组传输

           apply()和call()最大的作用是能扩充函数作用域
           window.color = "red";
           var o = {color : "blue"};
           function sayColor(){
           alert(this.color);
           }
           sayColor //red
           sayColor.call(this) //red
           sayColor.call(window);//red
           sayColor.call(o); //blue
           call()和apply()用来扩充作用域的最大好处是对象不需要与方法有耦合。

           bind方法()
           创建一个函数的实例，其this值会被绑定到传给bind()函数的值，即那个对象
           window.color = "red"
           var o = {color:"blue"}；
           function sayColor(){
           alert(this.color)；
           }
           var oSayColor = sayColor.bind(o);
           oSayColor();//blue