var functionName = function(arg0, arg1, arg2){
//函数体
}
因为function关键字后没有标识符，所有成为匿名函数，也叫拉姆达函数。
函数表达式和其他表达式一样，使用前要先赋值，否则会导致错误。
sayHi(); //错误：函数还不存在
var sayHi = function(){
alert("Hi!");
};
//不要这样做！
if(condition){
function sayHi(){
alert("Hi!");
}
} else {
function sayHi(){
alert("Yo!");
}
}
FunctionDeclarationsErrorExample01.htm
表面上看，以上代码表示在 condition 为 true 时，使用一个 sayHi() 的定义；否则，就使用另
一个定义。实际上，这在 ECMAScript 中属于无效语法，JavaScript 引擎会尝试修正错误，将其转换为合
理的状态。但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明，忽略
condition ；Firefox 会在 condition 为 true 时返回第一个声明。因此这种使用方式很危险，不应该
出现在你的代码中。不过，如果是使用函数表达式，那就没有什么问题了。
//可以这样做
var sayHi;
if(condition){
sayHi = function(){
alert("Hi!");
};
} else {
sayHi = function(){
alert("Yo!");
};
}

/******************闭包*********************************************/

闭包是指有权访问另一个
函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数

function createComparisonFunction(propertyName) {
return function(object1, object2){
var value1 = object1[propertyName];
var value2 = object2[propertyName];
if (value1 < value2){
return -1;
} else if (value1 > value2){
return 1;
} else {
return 0;
}
};
}
在这个例子中，突出的那两行代码是内部函数（一个匿名函数）中的代码，这两行代码访问了外部
函数中的变量 propertyName 。即使这个内部函数被返回了，而且是在其他地方被调用了，但它仍然可
以访问变量 propertyName 。之所以还能够访问这个变量，是因为内部函数的作用域链中包含
createComparisonFunction() 的作用域。要彻底搞清楚其中的细节，必须从理解函数被调用的时候
都会发生什么入手



由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过
度使用闭包可能会导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭
包。虽然像 V8 等优化后的 JavaScript 引擎会尝试回收被闭包占用的内存，但请大家
还是要慎重使用闭包




/******************闭包*********************************************/