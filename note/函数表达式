var functionName = function(arg0, arg1, arg2){
//函数体
}
因为function关键字后没有标识符，所有成为匿名函数，也叫拉姆达函数。
函数表达式和其他表达式一样，使用前要先赋值，否则会导致错误。
sayHi(); //错误：函数还不存在
var sayHi = function(){
alert("Hi!");
};
//不要这样做！
if(condition){
function sayHi(){
alert("Hi!");
}
} else {
function sayHi(){
alert("Yo!");
}
}
FunctionDeclarationsErrorExample01.htm
表面上看，以上代码表示在 condition 为 true 时，使用一个 sayHi() 的定义；否则，就使用另
一个定义。实际上，这在 ECMAScript 中属于无效语法，JavaScript 引擎会尝试修正错误，将其转换为合
理的状态。但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明，忽略
condition ；Firefox 会在 condition 为 true 时返回第一个声明。因此这种使用方式很危险，不应该
出现在你的代码中。不过，如果是使用函数表达式，那就没有什么问题了。
//可以这样做
var sayHi;
if(condition){
sayHi = function(){
alert("Hi!");
};
} else {
sayHi = function(){
alert("Yo!");
};
}

/******************闭包*********************************************/

闭包是指有权访问另一个
函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数

function createComparisonFunction(propertyName) {
return function(object1, object2){
var value1 = object1[propertyName];
var value2 = object2[propertyName];
if (value1 < value2){
return -1;
} else if (value1 > value2){
return 1;
} else {
return 0;
}
};
}
在这个例子中，突出的那两行代码是内部函数（一个匿名函数）中的代码，这两行代码访问了外部
函数中的变量 propertyName 。即使这个内部函数被返回了，而且是在其他地方被调用了，但它仍然可
以访问变量 propertyName 。之所以还能够访问这个变量，是因为内部函数的作用域链中包含
createComparisonFunction() 的作用域。要彻底搞清楚其中的细节，必须从理解函数被调用的时候
都会发生什么入手



由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过
度使用闭包可能会导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭
包。虽然像 V8 等优化后的 JavaScript 引擎会尝试回收被闭包占用的内存，但请大家
还是要慎重使用闭包




/******************闭包*********************************************/

/********************************块级作用域--***************************/

块级作用域通常称为私有作用域
(function(){
//这里是块级作用域
})();
以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个
函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。如果有读者感觉这种语法不太好理解，
可以再看看下面这个例子。
var count = 5;
outputNumbers(count);
这里初始化了变量 count ，将其值设置为 5。当然，这里的变量是没有必要的，因为可以把值直接
传给函数。为了让代码更简洁，我们在调用函数时用 5 来代替变量 count ，如下所示。
outputNumbers(5);
这样做之所以可行，是因为变量只不过是值的另一种表现形式，因此用实际的值替换变量没有问题。
再看下面的例子。
var someFunction = function(){
//这里是块级作用域
};
someFunction();
这个例子先定义了一个函数，然后立即调用了它。定义函数的方式是创建一个匿名函数，并把匿名
函数赋值给变量 someFunction 。而调用函数的方式是在函数名称后面添加一对圆括号，即
someFunction() 。通过前面的例子我们知道，可以使用实际的值来取代变量 count ，那在这里是不是
也可以用函数的值直接取代函数名呢？ 然而，下面的代码却会导致错误。
function(){
//这里是块级作用域
}(); //出错！
这段代码会导致语法错误，是因为 JavaScript 将 function 关键字当作一个函数声明的开始，而函
数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。要将函数声明转换成函数表达式，
只要像下面这样给它加上一对圆括号即可。
(function(){
//这里是块级作用域
})();

function outputNumbers(count){
(function () {
for (var i=0; i < count; i++){
alert(i);
}
})();
alert(i); //导致一个错误！
}
BlockScopeExample03.htm
在这个重写后的 outputNumbers() 函数中，我们在 for 循环外部插入了一个私有作用域。在匿名
函数中定义的任何变量，都会在执行结束时被销毁。因此，变量 i 只能在循环中使用，使用后即被销毁。
而在私有作用域中能够访问变量 count ，是因为这个匿名函数是一个闭包，它能够访问包含作用域中的
所有变量。















/********************************块级作用域--***************************/